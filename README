这是一个不需要重启就可以给整块硬盘或分区做快照的Linux内核模块，工作在通用块设备层，可以支持大多数常见的文件系统和各种文件系统块大小。

blsnapshot.c是内核模块，基于3.10版本内核，用centos7安装好相关的编译环境后，直接make就可以编译

snapshot.c是blsnapshot.c模块的用户空间控制程序，用法是: snapshot /dev/vdb /mnt/b/cow 30
"/dev/vdb" 表示对该磁盘做快照
"/mnt/b/cow" 文件用于存储被覆盖的原始旧数据
"30" 表示预分配30兆磁盘空间给 "/mnt/b/cow" 文件

执行完成后会生成一个新的块设备用来表示原磁盘的快照，路径是/dev/snapshot0，mount此块设备就可以查看快照

Linux块级磁盘快照内核模块的实现：
1，用自己的make_request_fn函数替换原块设备的make_request_fn函数以实现对做写入操作的bio的拦截（make_request_fn函数负责将新的bio加入到request_queue）。
2，根据第1步拦截下来的bio把将被覆盖的旧数据读取出来。
3，把第2步读取出来的数据复制到cow文件，同时记录“被覆盖的数据对应的块的编号”（以下简称为sects，据此可以判断该块对应的数据之前有没有被复制到cow文件，不重复复制）。
4，第2步的数据都读取完毕后，就调用原make_request_fn函数执行第1步被拦截的bio。
5，创建虚拟块设备作为原块设备的可挂载磁盘，并为虚拟块设备定义make_request_fn函数实现读取逻辑：如果要读取的bio对应的块全都没有被覆盖过就只读取原块设备，如果全都被覆盖过就只读取cow文件，如果部分被覆盖过就两个都读取并做混合，这里使用sects做判断。

该模块的sects占用内存情况的分析：
sects是通过一个2维数组作记录的，之所以要用2维数组而不是1维数组，最主要是为了节省内存。磁盘的块的编号需要8字节的整数才能容纳，所以如果采用一维数组且文件系统块的大小是512字节，在设置快照时就需要分配磁盘大小的 8 / 512 的内存来记录此编号 。
可以在概念上将磁盘当作由更大的块组成的（以下简称为块组），块组的大小应为2的n次方个内存页，每个块组包含多个文件系统块。采用二维数组来实现sects，第一维数组的索引是块组的编号，值是块组的内存地址（仅当该块组内有某个块被写入时才会为该块组创建内存页），第二维数组的索引是文件系统块在块组当中的编号，值是该块在磁盘中的编号。如此，在设置快照时只需要创建保存块组地址的第一维数组，假如块组的大小是2的3次方个内存页，那么sects占用的内存的大小是磁盘大小的 8 / (2^3 * 4096)。
